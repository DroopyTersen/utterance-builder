{"version":3,"sources":["webpack:///webpack/bootstrap 1a71ef00e6d45bb14660","webpack:///./site.js","webpack:///./~/alexa-utterances/index.js","webpack:///./~/js-combinatorics/combinatorics.js","webpack:///./~/numbered/index.js"],"names":["utterances","require","dom","find","selector","document","querySelectorAll","findOne","querySelector","buildUtterances","templates","map","t","r","trim","join","formSubmit","e","preventDefault","value","utterancesStr","split","addEventListener"],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;ACtCA,KAAIA,aAAa,mBAAAC,CAAQ,CAAR,CAAjB;;AAEA,KAAIC,MAAM;AACNC,WAAM,cAACC,QAAD;AAAA,6CAAkBC,SAASC,gBAAT,CAA0BF,QAA1B,CAAlB;AAAA,MADA;AAENG,cAAS,iBAACH,QAAD;AAAA,gBAAaC,SAASG,aAAT,CAAuBJ,QAAvB,CAAb;AAAA;AAFH,EAAV;;AAKA,KAAIK,kBAAkB,SAAlBA,eAAkB,CAASC,SAAT,EAAoB;AACtC,YAAOA,UACEC,GADF,CACM;AAAA,gBAAKX,WAAWY,CAAX,EAAcD,GAAd,CAAkB;AAAA,oBAAKE,EAAEC,IAAF,EAAL;AAAA,UAAlB,EAAiCC,IAAjC,CAAsC,IAAtC,CAAL;AAAA,MADN,EAEEA,IAFF,CAEO,IAFP,CAAP;AAGH,EAJD;;AAMA,KAAIC,aAAa,SAAbA,UAAa,CAASC,CAAT,EAAY;AACzBA,OAAEC,cAAF;AACA,SAAIC,QAAQjB,IAAIK,OAAJ,CAAY,qBAAZ,EAAmCY,KAA/C;AACA,SAAIA,KAAJ,EAAW;AACP,aAAIC,gBAAgBX,gBAAgBU,MAAME,KAAN,CAAY,IAAZ,CAAhB,CAApB;AACAnB,aAAIK,OAAJ,CAAY,4BAAZ,EAA0CY,KAA1C,GAAkDC,aAAlD;AACH;AACJ,EAPD;;AASAlB,KAAIK,OAAJ,CAAY,iBAAZ,EAA+Be,gBAA/B,CAAgD,QAAhD,EAA0DN,UAA1D,E;;;;;;ACtBA;AACA;;;AAGA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA,oBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;;AAEA;AACA,+CAA8C,OAAO;AACrD;AACA,+CAA8C;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,0DAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iDAAgD;AAChD;AACA,wBAAuB,KAAK,KAAK;;AAEjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA,6BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAa,oCAAoC;AACjD,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAqC,OAAO,sB;AAC5C,2B;AACA,QAAO;AACP;AACA,wCAAuC,OAAO,sB;AAC9C,mDAAkD,+BAA+B;AACjF,QAAO;AACP;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA,mBAAkB,OAAO,KAAK,KAAK;AACnC;AACA,kDAAiD,UAAU;AAC3D;;AAEA;AACA;;;AAGA;;;;;;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,OAAO;AAC9B;AACA,UAAS;AACT;AACA;AACA;AACA,eAAc,GAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,uBAAsB,GAAG;AACzB;AACA,cAAa;AACb;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,uBAAsB,GAAG;AACzB;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAmC,QAAQ;AAC3C;AACA;AACA,cAAa;AACb;AACA;AACA,U;AACA;AACA;AACA;AACA,4CAA2C,QAAQ;AACnD;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA,4BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA2C,SAAS;AACpD;AACA;AACA;AACA,4BAA2B,QAAQ;AACnC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,wBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,gCAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,uBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,uBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,gCAA+B,WAAW;AAC1C;AACA;AACA,4BAA2B;AAC3B;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,EAAC;;;;;;;AC7gBD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;AAED;AACA;AACA,EAAC;;AAED;AACA;AACA,aAAY,OAAO;AACnB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY,cAAc;AAC1B,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY,OAAO;AACnB,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iCAAgC,cAAc;AAC9C;AACA,sBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA4B,kBAAkB;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY,OAAO;AACnB,aAAY;AACZ;AACA;AACA,iCAAgC,cAAc;;AAE9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA,6BAA4B;AAC5B;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,mBAAkB;AAClB;AACA,0BAAyB;AACzB,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,uBAAuB;AACjD;AACA;AACA;;AAEA;AACA,gBAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 1a71ef00e6d45bb14660\n **/","var utterances = require(\"alexa-utterances\");\r\n\r\nvar dom = {\r\n    find: (selector) => [...document.querySelectorAll(selector)],\r\n    findOne: (selector) =>document.querySelector(selector)\r\n};\r\n\r\nvar buildUtterances = function(templates) {\r\n    return templates\r\n            .map(t => utterances(t).map(r => r.trim()).join(\"\\n\"))\r\n            .join(\"\\n\");\r\n}\r\n\r\nvar formSubmit = function(e) {\r\n    e.preventDefault();\r\n    var value = dom.findOne(\"#workspace textarea\").value;\r\n    if (value) {\r\n        var utterancesStr = buildUtterances(value.split(\"\\n\"));\r\n        dom.findOne(\"#utterance-output textarea\").value = utterancesStr;\r\n    }\r\n}\r\n\r\ndom.findOne(\"#workspace form\").addEventListener(\"submit\", formSubmit);\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./site.js\n **/","var Combinatorics = require('js-combinatorics');\nvar Numbered      = require('numbered');\n\n\n// Util functions for generating schema and utterances\n// ===================================================\n// Convert a number range like 5-10 into an array of english words\nfunction expandNumberRange(start, end, by) {\n  by = by || 1; //incrementing by 0 is a bad idea\n  var converted = [];\n  for (var i=start; i<=end; i+=by) {\n    converted.push( Numbered.stringify(i).replace(/-/g,' ') );\n  }\n  return converted;\n}\n\n// Determine if a curly brace expression is a Slot name literal\n// Returns true if expression is of the form {-|Name}, false otherwise\nfunction isSlotLiteral(braceExpression) {\n  return braceExpression.substring(0, 3) == \"{-|\";\n}\n\n// Recognize shortcuts in utterance definitions and swap them out with the actual values\nfunction expandShortcuts(str, slots, dictionary) {\n  // If the string is found in the dictionary, just provide the matching values\n  if (typeof dictionary==\"object\" && typeof dictionary[str]!=\"undefined\") {\n    return dictionary[str];\n  }\n  // Numbered ranges, ex: 5-100 by 5\n  var match = str.match(/(\\d+)\\s*-\\s*(\\d+)(\\s+by\\s+(\\d+))?/);\n  if (match) {\n    return expandNumberRange(+match[1],+match[2],+match[4]);\n  }\n  return [str];\n}\n\nvar slotIndexes = [];\nfunction expandSlotValues (variations, slotSampleValues) {\n  var i;\n\n  var slot;\n  for (slot in slotSampleValues) {\n\n    var sampleValues = slotSampleValues[slot];\n\n    var idx = -1;\n    if (typeof slotIndexes[slot] !== \"undefined\") {\n      idx = slotIndexes[slot];\n    }\n\n    var newVariations = [];\n\n    // make sure we have enough variations that we can get through the sample values\n    // at least once for each alexa-app utterance...  this isn't strictly as\n    // minimalistic as it could be.\n    //\n    // our *real* objective is to make sure that each sampleValue gets used once per\n    // intent, but each intent spans multiple utterances; it would require heavy\n    // restructuring of the way the utterances are constructed to keep track of\n    // whether every slot was given each sample value once within an Intent's set\n    // of utterances.  So we take the easier route, which generates more utterances\n    // in the output (but still many less than we would get if we did the full\n    // cartesian product).\n    if (variations.length < sampleValues.length) {\n      var mod = variations.length;\n      var xtraidx = 0;\n      while (variations.length < sampleValues.length) {\n        variations.push (variations[xtraidx]);\n        xtraidx = (xtraidx + 1) % mod;\n      }\n    }\n\n    variations.forEach (function (variation, j) {\n      var newVariation = [];\n      variation.forEach (function (value, k) {\n        if (value == \"slot-\" + slot) {\n          idx = (idx + 1) % sampleValues.length;\n          slotIndexes[slot] = idx;\n\n          value = sampleValues[idx];\n        }\n\n        newVariation.push (value);\n      });\n      newVariations.push (newVariation);\n    });\n\n    variations = newVariations;\n  }\n\n  return variations;\n}\n\n// Generate a list of utterances from a template\nfunction generateUtterances(str, slots, dictionary, exhaustiveUtterances) {\n  var placeholders=[], utterances=[], slotmap={}, slotValues=[];\n  // First extract sample placeholders values from the string\n  str = str.replace(/\\{([^\\}]+)\\}/g, function(match,p1) {\n\n    if (isSlotLiteral(match)) {\n      return match;\n    }\n\n    var expandedValues=[], slot, values = p1.split(\"|\");\n    // If the last of the values is a SLOT name, we need to keep the name in the utterances\n    if (values && values.length && values.length>1 && slots && typeof slots[values[values.length-1]]!=\"undefined\") {\n      slot = values.pop();\n    }\n    values.forEach(function(val,i) {\n      Array.prototype.push.apply(expandedValues,expandShortcuts(val,slots,dictionary));\n    });\n    if (slot) {\n      slotmap[slot] = placeholders.length;\n    }\n\n    // if we're dealing with minimal utterances, we will delay the expansion of the\n    // values for the slots; all the non-slot expansions need to be fully expanded\n    // in the cartesian product\n    if (!exhaustiveUtterances && slot)\n    {\n      placeholders.push( [ \"slot-\" + slot ] );\n      slotValues[slot] = expandedValues;\n    }\n    else\n    {\n      placeholders.push( expandedValues );\n    }\n\n    return \"{\"+(slot || placeholders.length-1)+\"}\";\n  });\n  // Generate all possible combinations using the cartesian product\n  if (placeholders.length>0) {\n    var variations = Combinatorics.cartesianProduct.apply(Combinatorics,placeholders).toArray();\n\n    if (!exhaustiveUtterances)\n    {\n      variations = expandSlotValues (variations, slotValues);\n    }\n\n    // Substitute each combination back into the original string\n    variations.forEach(function(values) {\n      // Replace numeric placeholders\n      var utterance = str.replace(/\\{(\\d+)\\}/g,function(match,p1){ \n        return values[p1]; \n      });\n      // Replace slot placeholders\n      utterance = utterance.replace(/\\{(.*?)\\}/g,function(match,p1){ \n        return (isSlotLiteral(match)) ? match : \"{\"+values[slotmap[p1]]+\"|\"+p1+\"}\";\n      });\n      utterances.push( utterance );\n    });\n  }\n  else {\n    utterances = [str];\n  }\n\n  // Convert all {-|Name} to {Name} to accomodate slot literals\n  for (var idx in utterances) {\n    utterances[idx] = utterances[idx].replace(/\\{\\-\\|/g, \"{\");\n  }\n\n  return utterances;\n}\n\n\nmodule.exports = generateUtterances;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/alexa-utterances/index.js\n ** module id = 1\n ** module chunks = 0\n **/","/*\n * $Id: combinatorics.js,v 0.25 2013/03/11 15:42:14 dankogai Exp dankogai $\n *\n *  Licensed under the MIT license.\n *  http://www.opensource.org/licenses/mit-license.php\n *\n *  References:\n *    http://www.ruby-doc.org/core-2.0/Array.html#method-i-combination\n *    http://www.ruby-doc.org/core-2.0/Array.html#method-i-permutation\n *    http://en.wikipedia.org/wiki/Factorial_number_system\n */\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define([], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.Combinatorics = factory();\n    }\n}(this, function () {\n    'use strict';\n    var version = \"0.5.2\";\n    /* combinatory arithmetics */\n    var P = function(m, n) {\n        var p = 1;\n        while (n--) p *= m--;\n        return p;\n    };\n    var C = function(m, n) {\n        if (n > m) {\n            return 0;\n        }\n        return P(m, n) / P(n, n);\n    };\n    var factorial = function(n) {\n        return P(n, n);\n    };\n    var factoradic = function(n, d) {\n        var f = 1;\n        if (!d) {\n            for (d = 1; f < n; f *= ++d);\n            if (f > n) f /= d--;\n        } else {\n            f = factorial(d);\n        }\n        var result = [0];\n        for (; d; f /= d--) {\n            result[d] = Math.floor(n / f);\n            n %= f;\n        }\n        return result;\n    };\n    /* common methods */\n    var addProperties = function(dst, src) {\n        Object.keys(src).forEach(function(p) {\n            Object.defineProperty(dst, p, {\n                value: src[p],\n                configurable: p == 'next'\n            });\n        });\n    };\n    var hideProperty = function(o, p) {\n        Object.defineProperty(o, p, {\n            writable: true\n        });\n    };\n    var toArray = function(f) {\n        var e, result = [];\n        this.init();\n        while (e = this.next()) result.push(f ? f(e) : e);\n        this.init();\n        return result;\n    };\n    var common = {\n        toArray: toArray,\n        map: toArray,\n        forEach: function(f) {\n            var e;\n            this.init();\n            while (e = this.next()) f(e);\n            this.init();\n        },\n        filter: function(f) {\n            var e, result = [];\n            this.init();\n            while (e = this.next()) if (f(e)) result.push(e);\n            this.init();\n            return result;\n        },\n        lazyMap: function(f) {\n            this._lazyMap = f;\n            return this;\n        },\n        lazyFilter: function(f) {\n            Object.defineProperty(this, 'next', {\n                writable: true\n            });\n            if (typeof f !== 'function') {\n                this.next = this._next;\n            } else {\n                if (typeof (this._next) !== 'function') {\n                    this._next = this.next;\n                }\n                var _next = this._next.bind(this);\n                this.next = (function() {\n                    var e;\n                    while (e = _next()) {\n                        if (f(e))\n                            return e;\n                    }\n                    return e;\n                }).bind(this);\n            }\n            Object.defineProperty(this, 'next', {\n                writable: false\n            });\n            return this;\n        }\n\n    };\n    /* power set */\n    var power = function(ary, fun) {\n        var size = 1 << ary.length,\n            sizeOf = function() {\n                return size;\n            },\n            that = Object.create(ary.slice(), {\n                length: {\n                    get: sizeOf\n                }\n            });\n        hideProperty(that, 'index');\n        addProperties(that, {\n            valueOf: sizeOf,\n            init: function() {\n                that.index = 0;\n            },\n            nth: function(n) {\n                if (n >= size) return;\n                var i = 0,\n                    result = [];\n                for (; n; n >>>= 1, i++) if (n & 1) result.push(this[i]);\n                return (typeof (that._lazyMap) === 'function')?that._lazyMap(result):result;\n            },\n            next: function() {\n                return this.nth(this.index++);\n            }\n        });\n        addProperties(that, common);\n        that.init();\n        return (typeof (fun) === 'function') ? that.map(fun) : that;\n    };\n    /* combination */\n    var nextIndex = function(n) {\n        var smallest = n & -n,\n            ripple = n + smallest,\n            new_smallest = ripple & -ripple,\n            ones = ((new_smallest / smallest) >> 1) - 1;\n        return ripple | ones;\n    };\n    var combination = function(ary, nelem, fun) {\n        if (!nelem) nelem = ary.length;\n        if (nelem < 1) throw new RangeError;\n        if (nelem > ary.length) throw new RangeError;\n        var first = (1 << nelem) - 1,\n            size = C(ary.length, nelem),\n            maxIndex = 1 << ary.length,\n            sizeOf = function() {\n                return size;\n            },\n            that = Object.create(ary.slice(), {\n                length: {\n                    get: sizeOf\n                }\n            });\n        hideProperty(that, 'index');\n        addProperties(that, {\n            valueOf: sizeOf,\n            init: function() {\n                this.index = first;\n            },\n            next: function() {\n                if (this.index >= maxIndex) return;\n                var i = 0,\n                    n = this.index,\n                    result = [];\n                for (; n; n >>>= 1, i++) {\n                    if (n & 1) result[result.length] = this[i];\n                }\n\n                this.index = nextIndex(this.index);\n                return (typeof (that._lazyMap) === 'function')?that._lazyMap(result):result;\n            }\n        });\n        addProperties(that, common);\n        that.init();\n        return (typeof (fun) === 'function') ? that.map(fun) : that;\n    };\n    /* bigcombination */\n    var bigNextIndex = function(n, nelem) {\n\n        var result = n;\n        var j = nelem;\n        var i = 0;\n        for (i = result.length - 1; i >= 0; i--) {\n            if (result[i] == 1) {\n                j--;\n            } else {\n                break;\n            }\n        } \n        if (j == 0) {\n            // Overflow\n            result[result.length] = 1;\n            for (var k = result.length - 2; k >= 0; k--) {\n                result[k] = (k < nelem-1)?1:0;\n            }\n        } else {\n            // Normal\n\n            // first zero after 1\n            var i1 = -1;\n            var i0 = -1;\n            for (var i = 0; i < result.length; i++) {\n                if (result[i] == 0 && i1 != -1) {\n                    i0 = i;\n                }\n                if (result[i] == 1) {\n                    i1 = i;\n                }\n                if (i0 != -1 && i1 != -1) {\n                    result[i0] = 1;\n                    result[i1] = 0;\n                    break;\n                }\n            }\n\n            j = nelem;\n            for (var i = result.length - 1; i >= i1; i--) {\n                if (result[i] == 1)\n                    j--;\n            }\n            for (var i = 0; i < i1; i++) {\n                result[i] = (i < j)?1:0;\n            }\n        }\n\n        return result;\n\n    };\n    var buildFirst = function(nelem) {\n        var result = [];\n        for (var i = 0; i < nelem; i++) {\n            result[i] = 1;\n        }\n        result[0] = 1;\n        return result;\n    };\n    var bigCombination = function(ary, nelem, fun) {\n        if (!nelem) nelem = ary.length;\n        if (nelem < 1) throw new RangeError;\n        if (nelem > ary.length) throw new RangeError;\n        var first = buildFirst(nelem),\n            size = C(ary.length, nelem),\n            maxIndex = ary.length,\n            sizeOf = function() {\n                return size;\n            },\n            that = Object.create(ary.slice(), {\n                length: {\n                    get: sizeOf\n                }\n            });\n        hideProperty(that, 'index');\n        addProperties(that, {\n            valueOf: sizeOf,\n            init: function() {\n                this.index = first.concat();\n            },\n            next: function() {\n                if (this.index.length > maxIndex) return;\n                var i = 0,\n                    n = this.index,\n                    result = [];\n                for (var j = 0; j < n.length; j++, i++) {\n                    if (n[j])\n                        result[result.length] = this[i];\n                }\n                bigNextIndex(this.index, nelem);\n                return (typeof (that._lazyMap) === 'function')?that._lazyMap(result):result;\n            }\n        });\n        addProperties(that, common);\n        that.init();\n        return (typeof (fun) === 'function') ? that.map(fun) : that;\n    };\n    /* permutation */\n    var _permutation = function(ary) {\n        var that = ary.slice(),\n            size = factorial(that.length);\n        that.index = 0;\n        that.next = function() {\n            if (this.index >= size) return;\n            var copy = this.slice(),\n                digits = factoradic(this.index, this.length),\n                result = [],\n                i = this.length - 1;\n            for (; i >= 0; --i) result.push(copy.splice(digits[i], 1)[0]);\n            this.index++;\n            return (typeof (that._lazyMap) === 'function')?that._lazyMap(result):result;\n        };\n        return that;\n    };\n    // which is really a permutation of combination\n    var permutation = function(ary, nelem, fun) {\n        if (!nelem) nelem = ary.length;\n        if (nelem < 1) throw new RangeError;\n        if (nelem > ary.length) throw new RangeError;\n        var size = P(ary.length, nelem),\n            sizeOf = function() {\n                return size;\n            },\n            that = Object.create(ary.slice(), {\n                length: {\n                    get: sizeOf\n                }\n            });\n        hideProperty(that, 'cmb');\n        hideProperty(that, 'per');\n        addProperties(that, {\n            valueOf: function() {\n                return size;\n            },\n            init: function() {\n                this.cmb = combination(ary, nelem);\n                this.per = _permutation(this.cmb.next());\n            },\n            next: function() {\n                var result = this.per.next();\n                if (!result) {\n                    var cmb = this.cmb.next();\n                    if (!cmb) return;\n                    this.per = _permutation(cmb);\n                    return this.next();\n                }\n                return (typeof (that._lazyMap) === 'function')?that._lazyMap(result):result;\n            }\n        });\n        addProperties(that, common);\n        that.init();\n        return (typeof (fun) === 'function') ? that.map(fun) : that;\n    };\n\n    var PC = function(m) {\n        var total = 0;\n        for (var n = 1; n <= m; n++) {\n            var p = P(m,n);\n            total += p;\n        };\n        return total;\n    };\n    // which is really a permutation of combination\n    var permutationCombination = function(ary, fun) {\n        // if (!nelem) nelem = ary.length;\n        // if (nelem < 1) throw new RangeError;\n        // if (nelem > ary.length) throw new RangeError;\n        var size = PC(ary.length),\n            sizeOf = function() {\n                return size;\n            },\n            that = Object.create(ary.slice(), {\n                length: {\n                    get: sizeOf\n                }\n            });\n        hideProperty(that, 'cmb');\n        hideProperty(that, 'per');\n        hideProperty(that, 'nelem');\n        addProperties(that, {\n            valueOf: function() {\n                return size;\n            },\n            init: function() {\n                this.nelem = 1;\n                // console.log(\"Starting nelem: \" + this.nelem);\n                this.cmb = combination(ary, this.nelem);\n                this.per = _permutation(this.cmb.next());\n            },\n            next: function() {\n                var result = this.per.next();\n                if (!result) {\n                    var cmb = this.cmb.next();\n                    if (!cmb) {\n                        this.nelem++;\n                        // console.log(\"increment nelem: \" + this.nelem + \" vs \" + ary.length);\n                        if (this.nelem > ary.length) return;\n                        this.cmb = combination(ary, this.nelem);\n                        cmb = this.cmb.next();\n                        if (!cmb) return;\n                    }\n                    this.per = _permutation(cmb);\n                    return this.next();\n                }\n                return (typeof (that._lazyMap) === 'function')?that._lazyMap(result):result;\n            }\n        });\n        addProperties(that, common);\n        that.init();\n        return (typeof (fun) === 'function') ? that.map(fun) : that;\n    };\n    /* Cartesian Product */\n    var arraySlice = Array.prototype.slice;\n    var cartesianProduct = function() {\n        if (!arguments.length) throw new RangeError;\n        var args = arraySlice.call(arguments),\n            size = args.reduce(function(p, a) {\n                return p * a.length;\n            }, 1),\n            sizeOf = function() {\n                return size;\n            },\n            dim = args.length,\n            that = Object.create(args, {\n                length: {\n                    get: sizeOf\n                }\n            });\n        if (!size) throw new RangeError;\n        hideProperty(that, 'index');\n        addProperties(that, {\n            valueOf: sizeOf,\n            dim: dim,\n            init: function() {\n                this.index = 0;\n            },\n            get: function() {\n                if (arguments.length !== this.length) return;\n                var result = [],\n                    d = 0;\n                for (; d < dim; d++) {\n                    var i = arguments[d];\n                    if (i >= this[d].length) return;\n                    result.push(this[d][i]);\n                }\n                return (typeof (that._lazyMap) === 'function')?that._lazyMap(result):result;\n            },\n            nth: function(n) {\n                var result = [],\n                    d = 0;\n                for (; d < dim; d++) {\n                    var l = this[d].length;\n                    var i = n % l;\n                    result.push(this[d][i]);\n                    n -= i;\n                    n /= l;\n                }\n                return (typeof (that._lazyMap) === 'function')?that._lazyMap(result):result;\n            },\n            next: function() {\n                if (this.index >= size) return;\n                var result = this.nth(this.index);\n                this.index++;\n                return result;\n            }\n        });\n        addProperties(that, common);\n        that.init();\n        return that;\n    };\n    /* baseN */\n    var baseN = function(ary, nelem, fun) {\n                if (!nelem) nelem = ary.length;\n        if (nelem < 1) throw new RangeError;\n        var base = ary.length,\n                size = Math.pow(base, nelem);\n        var sizeOf = function() {\n                return size;\n            },\n            that = Object.create(ary.slice(), {\n                length: {\n                    get: sizeOf\n                }\n            });\n        hideProperty(that, 'index');\n        addProperties(that, {\n            valueOf: sizeOf,\n            init: function() {\n                that.index = 0;\n            },\n            nth: function(n) {\n                if (n >= size) return;\n                var result = [];\n                for (var i = 0; i < nelem; i++) {\n                    var d = n % base;\n                    result.push(ary[d])\n                    n -= d; n /= base\n                }\n                return (typeof (that._lazyMap) === 'function')?that._lazyMap(result):result;\n            },\n            next: function() {\n                return this.nth(this.index++);\n            }\n        });\n        addProperties(that, common);\n        that.init();\n        return (typeof (fun) === 'function') ? that.map(fun) : that;\n    };\n\n    /* export */\n    var Combinatorics = Object.create(null);\n    addProperties(Combinatorics, {\n        C: C,\n        P: P,\n        factorial: factorial,\n        factoradic: factoradic,\n        cartesianProduct: cartesianProduct,\n        combination: combination,\n        bigCombination: bigCombination,\n        permutation: permutation,\n        permutationCombination: permutationCombination,\n        power: power,\n        baseN: baseN,\n        VERSION: version\n    });\n    return Combinatorics;\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/js-combinatorics/combinatorics.js\n ** module id = 2\n ** module chunks = 0\n **/","var numbers = {\n  '.': 'point',\n  '-': 'negative',\n  0: 'zero',\n  1: 'one',\n  2: 'two',\n  3: 'three',\n  4: 'four',\n  5: 'five',\n  6: 'six',\n  7: 'seven',\n  8: 'eight',\n  9: 'nine',\n  10: 'ten',\n  11: 'eleven',\n  12: 'twelve',\n  13: 'thirteen',\n  14: 'fourteen',\n  15: 'fifteen',\n  16: 'sixteen',\n  17: 'seventeen',\n  18: 'eighteen',\n  19: 'nineteen',\n  20: 'twenty',\n  30: 'thirty',\n  40: 'forty',\n  50: 'fifty',\n  60: 'sixty',\n  70: 'seventy',\n  80: 'eighty',\n  90: 'ninety'\n};\n\n// http://en.wikipedia.org/wiki/English_numerals#Cardinal_numbers\nvar helpers = {};\n// Store the helpers in the power of tens\nhelpers[2]   = 'hundred';\nhelpers[3]   = 'thousand';\nhelpers[6]   = 'million';\nhelpers[9]   = 'billion';\nhelpers[12]  = 'trillion';\nhelpers[15]  = 'quadrillion';\nhelpers[18]  = 'quintillion';\nhelpers[21]  = 'sextillion';\nhelpers[24]  = 'septillion';\nhelpers[27]  = 'octillion';\nhelpers[30]  = 'nonillion';\nhelpers[33]  = 'decillion';\nhelpers[36]  = 'undecillion';\nhelpers[39]  = 'duodecillion';\nhelpers[42]  = 'tredecillion';\nhelpers[45]  = 'quattuordecillion';\nhelpers[48]  = 'quindecillion';\nhelpers[51]  = 'sexdecillion';\nhelpers[54]  = 'septendecillion';\nhelpers[57]  = 'octodecillion';\nhelpers[60]  = 'novemdecillion';\nhelpers[63]  = 'vigintillion';\nhelpers[100] = 'googol';\nhelpers[303] = 'centillion';\n\n// Make a hash of the numbers and helper numbers reversed\n// E.g. The key as the word and value as the number\nvar numbersMap = {};\nnumbersMap.nil     = 0;\nnumbersMap.naught  = 0;\nnumbersMap.period  = '.';\nnumbersMap.decimal = '.';\n\nObject.keys(numbers).forEach(function (num) {\n  numbersMap[numbers[num]] = isNaN(+num) ? num : +num;\n});\n\nObject.keys(helpers).forEach(function (num) {\n  numbersMap[helpers[num]] = isNaN(+num) ? num : Math.pow(10, +num);\n});\n\n/**\n * Returns the number of significant figures for the number\n * @param  {number} num\n * @return {number}\n */\nvar intervals = function (num) {\n  var match;\n  if ((match = ('' + num).match(/e\\+(\\d+)/))) {\n    return match[1];\n  }\n\n  return ('' + num).length - 1;\n};\n\n/**\n * Accepts both a string and number type - and return the opposite\n * @param  {string|number} num\n * @return {string|number}\n */\nvar numberWords = module.exports = function (num) {\n  if (typeof num === 'string') {\n    return numberWords.parse(num);\n  }\n  if (typeof num === 'number') {\n    return numberWords.stringify(num);\n  }\n  throw new Error('Number words can handle handle numbers and/or strings');\n};\n\n/**\n * Turn a number into a string representation\n * @param  {number} num\n * @return {string}\n */\nnumberWords.stringify = function (num) {\n  var word = [],\n      interval,\n      remaining;\n\n  num = isNaN(+num) ? num : +num;\n\n  // Numbers are super buggy in JS over 10^20\n  if (typeof num !== 'number') { return false; }\n  // If the number is in the numbers object, we can quickly return\n  if (numbers[num]) { return numbers[num]; }\n  // If the number is a negative value\n  if (num < 0) {\n    return numbers['-'] + ' ' + numberWords.stringify(num * -1);\n  }\n\n  // Check if we have decimals\n  if (num % 1) {\n    word.push(numberWords.stringify(Math.floor(num)));\n    word.push(numbers['.']);\n    word = word.concat(('' + num).split('.')[1].split('').map(numberWords.stringify));\n    return word.join(' ');\n  }\n\n  interval = intervals(num);\n  // It's below one hundred, but greater than nine\n  if (interval === 1) {\n    word.push(numbers[Math.floor(num / 10) * 10] + '-' + numberWords.stringify(Math.floor(num % 10)));\n  }\n  // Simple check to find the closest full number helper\n  while (interval > 3 && !helpers[interval]) {\n    interval -= 1;\n  }\n\n  if (helpers[interval]) {\n    remaining = Math.floor(num % Math.pow(10, interval));\n    word.push(numberWords.stringify(Math.floor(num / Math.pow(10, interval))));\n    word.push(helpers[interval] + (remaining > 99 ? ',' : ''));\n    if (remaining) {\n      if (remaining < 100) { word.push('and'); }\n      word.push(numberWords.stringify(remaining));\n    }\n  }\n\n  return word.join(' ');\n};\n\n/**\n * Turns a string representation of a number into a number type\n * @param  {string} num\n * @return {number}\n */\nnumberWords.parse = function (num) {\n  if (typeof num !== 'string') { return false; }\n\n  var modifier        = 1,\n      largest         = 0,\n      largestInterval = 0,\n      zeros           = 0, // Keep track of the number of leading zeros in the decimal\n      stack           = [];\n\n  var totalStack = function () {\n    var total = stack.reduceRight(function (memo, num, index, array) {\n      if (num > array[index + 1]) {\n        return memo * num;\n      }\n      return memo + num;\n    }, 0);\n\n    return total * largest;\n  };\n\n  var total = num.split(/\\W+/g).map(function (num) {\n    num = num.toLowerCase(); // Make life easier\n    return numbersMap[num] != null ? numbersMap[num] : num;\n  }).filter(function (num) {\n    if (num === '-') {\n      modifier = -1;\n    }\n    if (num === '.') {\n      return true; // Decimal points are a special case\n    }\n    return isFinite(num); // Remove numbers we don't understand\n  }).reduceRight(function (memo, num) {\n    var interval = intervals(num),\n        decimals,\n        output;\n\n    // Check the interval is smaller than the largest one, then create a stack\n    if (typeof num === 'number' && interval < largestInterval) {\n      if (!stack.length) { memo = memo - largest; }\n      stack.push(num);\n      return memo;\n    }\n\n    memo  = memo + totalStack();\n    stack = []; // Reset the stack for more computations\n\n    // If the number is a decimal, transform everything we were just working with\n    if (num === '.') {\n      decimals = zeros + ('' + memo).length;\n      zeros    = 0;\n      // Reset the largest intervals and stuff\n      largest         = 0;\n      largestInterval = 0;\n      return memo * Math.pow(10, decimals * -1);\n    }\n\n    // Keep a count of zeros we encountered\n    if (num === 0) {\n      zeros += 1;\n      return memo;\n    }\n\n    // Shove the number on the front if the intervals match and the number is a whole\n    if (memo >= 1 && interval === largestInterval) {\n      output = '' + memo;\n      // Decrement the zeros count while adding zeros to the front of the number\n      while (zeros && zeros--) {\n        output = '0' + output;\n      }\n      return +(num + output);\n    }\n\n    // Store the largest number for future use\n    largest         = num;\n    largestInterval = intervals(largest);\n\n    return (memo + num) * Math.pow(10, zeros);\n  }, 0);\n\n  return modifier * (total + totalStack());\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/numbered/index.js\n ** module id = 3\n ** module chunks = 0\n **/"],"sourceRoot":""}